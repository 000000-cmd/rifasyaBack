# Nombre del workflow
name: Deploy Spring Boot App to AWS EC2

# Evento que dispara el workflow: un push a la rama main
on:
  push:
    branches: [ "main" ] # <-- ¡Recuerda cambiar "main" si tu rama se llama diferente!

# Tareas a ejecutar
jobs:
  deploy:
    # La máquina virtual temporal donde se ejecutará el workflow
    runs-on: ubuntu-latest
    steps:
    # 1. Clona tu repositorio en la máquina virtual
    - name: Checkout code
      uses: actions/checkout@v3

    # 2. Configura Java
    - name: Set up JDK 21
      uses: actions/setup-java@v3
      with:
        java-version: '21' # <-- Cambia '21' por la versión de tu proyecto si es diferente
        distribution: 'corretto'

    # 3. Construye el proyecto con Maven para generar el .jar
    - name: Build with Maven
      run: mvn clean package

    # 4. Sube el nuevo .jar al servidor EC2
    - name: SCP to EC2
      uses: appleboy/scp-action@master
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        source: "target/*.jar"
        target: "~/"

    # 5. Se conecta por SSH y reinicia la aplicación
    - name: Restart application on EC2
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        script: |
          # Encuentra el ID del proceso Java que ya está corriendo
          PID=$(pgrep -f .jar)
          # Si el proceso existe, lo mata para detener la versión anterior
          if [ -n "$PID" ]; then
            kill -9 $PID
          fi
          # Inicia la nueva versión del .jar en segundo plano con la memoria asignada
          nohup java -Xmx400m -jar *.jar &
